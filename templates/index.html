<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assistente de Email Personalizado</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        /* Estilos gerais e responsivos */
        body {
            padding: 20px;
            background-color: #f8f9fa; /* Fundo cinza claro */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Fonte moderna */
        }
        .container {
            max-width: 900px; /* Container um pouco mais largo */
            background-color: #ffffff; /* Fundo branco para o conteúdo */
            padding: 30px;
            border-radius: 8px; /* Cantos arredondados */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* Sombra subtil */
            margin: 20px auto; /* Centrar container */
        }
        h1, h2, h3, h4 {
            color: #343a40; /* Cor cinza escuro para títulos */
            margin-bottom: 1.2rem;
            font-weight: 600; /* Títulos ligeiramente mais negritos */
        }
        .form-label {
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: block;
            color: #495057; /* Cor da label */
        }
        .form-label-sm { /* Label mais pequena */
            font-size: 0.875em;
            font-weight: normal;
            color: #495057;
        }
        textarea.form-control {
            min-height: 150px; /* Altura padrão da textarea */
            border-radius: 5px;
            border: 1px solid #ced4da; /* Borda padrão */
        }
        textarea.form-control:focus {
            border-color: #86b7fe; /* Cor de foco Bootstrap */
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25); /* Sombra de foco Bootstrap */
        }
        .analysis-section, .draft-section {
            margin-top: 30px;
            border-top: 1px solid #dee2e6; /* Linha separadora */
            padding-top: 25px;
        }

        /* Estilos para os grupos de input do utilizador (pontos) */
        .point-input-group {
            margin-bottom: 25px; /* Margem aumentada */
            padding: 20px; /* Padding aumentado */
            background-color: #eef2f7; /* Fundo cinza-azulado claro */
            border-radius: 5px;
            border: 1px solid #d1d9e6; /* Borda ligeiramente mais escura */
            transition: background-color 0.2s ease-in-out; /* Efeito hover suave */
        }
        .point-input-group:hover {
             background-color: #e3e9f1; /* Ligeiramente mais escuro no hover */
        }
        .point-input-group .form-label {
            font-weight: normal; /* Peso normal para sub-labels */
            margin-bottom: 0.25rem;
        }
        .point-input-group p.point-text { /* Texto do ponto original */
            margin-bottom: 1rem;
            font-size: 0.95rem;
            color: #495057;
            font-style: italic;
            background-color: #fff; /* Fundo branco para contraste */
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ced4da;
        }
        .point-input-group textarea { /* Textarea de orientação */
            min-height: 70px;
            margin-top: 10px;
        }
        .guidance-direction-group { /* Grupo de botões de rádio (direção) */
            margin-bottom: 1rem;
        }
        .guidance-direction-group .form-check-label {
            font-size: 0.9em;
        }

        /* Estilos do Spinner de Carregamento */
        .loading-spinner {
            display: none; /* Escondido por defeito */
            width: 1.2rem;
            height: 1.2rem;
            vertical-align: text-bottom; /* Alinhar com texto do botão */
        }
        .btn-sm .loading-spinner, .refine-btn .loading-spinner { /* Spinner mais pequeno */
             width: 0.8rem;
             height: 0.8rem;
             vertical-align: middle; /* Centrar melhor em botões pequenos */
        }

        /* Estilos de Mensagem de Erro */
        .error-message {
            color: #dc3545; /* Cor de perigo Bootstrap */
            font-weight: bold;
            margin-top: 10px;
            font-size: 0.9rem;
            display: none; /* Escondido por defeito */
        }
        .is-invalid { /* Estilo para campo inválido */
            border-color: #dc3545 !important;
        }

        /* Estilos Gerais de Botões */
        .btn {
            margin-right: 5px;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;
        }
        .btn-primary { background-color: #0d6efd; border-color: #0d6efd; }
        .btn-success { background-color: #198754; border-color: #198754; }
        .btn-secondary { background-color: #6c757d; border-color: #6c757d; }
        .btn-warning { background-color: #ffc107; border-color: #ffc107; color: #000; }
        .btn-outline-secondary { /* Estilos para botão 'Sugerir Texto' */
             --bs-btn-color: #6c757d;
             --bs-btn-border-color: #6c757d;
             --bs-btn-hover-color: #fff;
             --bs-btn-hover-bg: #6c757d;
             --bs-btn-hover-border-color: #6c757d;
             --bs-btn-focus-shadow-rgb: 108,117,125;
             --bs-btn-active-color: #fff;
             --bs-btn-active-bg: #6c757d;
             --bs-btn-active-border-color: #6c757d;
             --bs-btn-active-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
             --bs-btn-disabled-color: #6c757d;
             --bs-btn-disabled-bg: transparent;
             --bs-btn-disabled-border-color: #6c757d;
             --bs-gradient: none;
        }

        /* Estilos para Botões de Refinamento */
        #refinementControls {
            margin-top: 10px; /* Espaço acima dos botões */
            padding: 10px;
            background-color: #f8f9fa; /* Fundo ligeiramente diferente */
            border-radius: 5px;
            border: 1px solid #dee2e6;
            display: none; /* Começa escondido */
            flex-wrap: wrap; /* Permite que botões quebrem linha */
            gap: 5px; /* Espaço entre botões */
        }
        .refine-btn {
            font-size: 0.8rem; /* Botões mais pequenos */
            padding: 0.25rem 0.6rem;
            display: inline-flex; /* Para alinhar spinner e texto */
            align-items: center; /* Alinhar verticalmente */
        }
        .refine-btn .loading-spinner { /* Spinner dentro dos botões */
            margin-left: 5px;
        }

        /* Ajustes Responsivos */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .container { padding: 20px; }
            h1 { font-size: 1.8rem; }
            h2 { font-size: 1.5rem; }
            .point-input-group { padding: 15px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="text-center mb-4">
            <h1>Assistente de Email Personalizado</h1>
            <p class="lead">Analise emails e gere rascunhos com Gemini usando personas definidas</p>
        </header>

        <section id="emailInputSection" class="mb-4">
            <label for="originalEmail" class="form-label">Cole aqui o Email Recebido:</label>
            <textarea class="form-control" id="originalEmail" rows="8" placeholder="Ex: Assunto: Reunião de Projeto... Caro Professor..."></textarea>
            <div class="mt-3">
                <button id="analyzeBtn" class="btn btn-primary">
                    Analisar Email
                    <div class="spinner-border spinner-border-sm text-light ms-1 loading-spinner" role="status" id="analyzeSpinner"></div>
                </button>
            </div>
            <div id="analyzeError" class="error-message"></div> </section>

        <section class="analysis-section" id="analysisSection" style="display: none;">
            <h2>Análise do Email</h2>
            <div id="analysisResult">
                </div>

            <div id="userInputsContainer" class="mt-4">
                <h3>Sua Resposta / Orientações</h3>
                <div id="userInputsSection">
                    </div>
            </div>

            <div class="mt-4">
                <label for="personaSelect" class="form-label">Selecione a Persona (Voz) para Responder:</label>
                <select class="form-select" id="personaSelect" {% if error_loading_personas %}disabled{% endif %}>
                    {% if error_loading_personas %}
                        <option value="">Erro ao carregar personas</option>
                    {% elif personas_dict %}
                        {% for key, persona in personas_dict.items() %}
                            <option value="{{ key }}">{{ persona.name }}</option>
                        {% endfor %}
                    {% else %}
                         <option value="">Nenhuma persona disponível</option>
                    {% endif %}
                </select>
                 {% if error_loading_personas %}
                     <div class="text-danger small mt-1">Não foi possível carregar as personas do ficheiro 'personas.json'. Verifique os logs do servidor.</div>
                 {% endif %}
            </div>

            <div class="mt-3">
                <button id="draftBtn" class="btn btn-success" {% if error_loading_personas or not personas_dict %}disabled{% endif %}>
                    Gerar Rascunho da Resposta
                    <div class="spinner-border spinner-border-sm text-light ms-1 loading-spinner" role="status" id="draftSpinner"></div>
                </button>
            </div>
            <div id="draftError" class="error-message"></div> </section>

        <section class="draft-section" id="draftSection" style="display: none;">
            <h2>Rascunho da Resposta Gerado (Editável)</h2>
            <textarea class="form-control" id="generatedDraft" rows="12" placeholder="O rascunho da resposta aparecerá aqui... Pode editar diretamente."></textarea>

            <div id="refinementControls" style="display: none;">
                <small class="text-muted w-100 mb-1 d-block">Refinar seleção:</small>
                <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="make_formal" title="Tornar texto selecionado mais formal">
                    Formalizar <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                </button>
                <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="make_casual" title="Tornar texto selecionado mais casual">
                    Casual <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                </button>
                <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="shorten" title="Encurtar texto selecionado">
                    Encurtar <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                </button>
                <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="expand" title="Expandir / Elaborar texto selecionado">
                    Expandir <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                </button>
                 <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="simplify" title="Simplificar linguagem do texto selecionado">
                    Simplificar <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                </button>
                 <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="improve_flow" title="Melhorar fluidez/coesão do texto selecionado">
                    Fluidez <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                </button>
                 <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="rephrase" title="Reescrever texto selecionado de outra forma">
                    Rephrase <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                </button>
                <button class="btn btn-sm btn-outline-secondary refine-btn" data-action="translate_en" title="Traduzir texto selecionado para Inglês">
                    Traduzir EN <span class="loading-spinner spinner-border spinner-border-sm" role="status"></span>
                 </button>
                 </div>

            <div class="mt-2 d-flex justify-content-between align-items-center">
                 <button id="copyDraftBtn" class="btn btn-secondary" title="Copiar o texto atual da caixa acima">
                     Copiar Texto Editado
                 </button>
                <div id="contextInfo" class="small text-muted ms-3" style="display: none; text-align: right;">
                    <strong>Contexto Usado:</strong> <span id="contextDetails"></span>
                </div>
            </div>
        </section>

    </div> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <script>
        // --- Seletores de Elementos DOM ---
        const originalEmailEl = document.getElementById('originalEmail');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const analyzeSpinner = document.getElementById('analyzeSpinner');
        const analyzeErrorEl = document.getElementById('analyzeError');
        const analysisSection = document.getElementById('analysisSection');
        const analysisResultEl = document.getElementById('analysisResult');
        const userInputsContainer = document.getElementById('userInputsContainer');
        const userInputsSection = document.getElementById('userInputsSection');
        const personaSelect = document.getElementById('personaSelect');
        const draftBtn = document.getElementById('draftBtn');
        const draftSpinner = document.getElementById('draftSpinner');
        const draftErrorEl = document.getElementById('draftError'); // Erro para draft e refine
        const draftSection = document.getElementById('draftSection');
        const generatedDraftEl = document.getElementById('generatedDraft');
        const copyDraftBtn = document.getElementById('copyDraftBtn');
        const contextInfoEl = document.getElementById('contextInfo');
        const contextDetailsEl = document.getElementById('contextDetails');
        const refinementControlsEl = document.getElementById('refinementControls'); // Controlos de refinamento

        // --- Estado da Aplicação ---
        let currentAnalysisPoints = []; // Armazena os pontos da análise
        let isRefining = false; // Flag para evitar chamadas de refinamento concorrentes

        // --- Funções Auxiliares ---
        function showSpinner(spinner) { if(spinner) spinner.style.display = 'inline-block'; }
        function hideSpinner(spinner) { if(spinner) spinner.style.display = 'none'; }
        function showError(element, message) { element.textContent = message; element.style.display = 'block'; }
        function hideError(element) { element.textContent = ''; element.style.display = 'none'; }
        // Função básica para escapar HTML
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        // --- Lógica Principal ---

        // 1. Event Listener: Botão "Analisar Email"
        analyzeBtn.addEventListener('click', async () => {
            const emailText = originalEmailEl.value.trim();
            // Validação básica
            if (!emailText) {
                showError(analyzeErrorEl, "Por favor, insira o texto do email recebido.");
                originalEmailEl.focus();
                originalEmailEl.classList.add('is-invalid');
                return;
            } else {
                 originalEmailEl.classList.remove('is-invalid');
            }

            // Reset da UI
            showSpinner(analyzeSpinner);
            hideError(analyzeErrorEl);
            hideError(draftErrorEl); // Limpa erro de draft/refine também
            analysisSection.style.display = 'none';
            draftSection.style.display = 'none';
            refinementControlsEl.style.display = 'none'; // Esconde botões de refinamento
            analysisResultEl.innerHTML = '';
            userInputsSection.innerHTML = '';
            generatedDraftEl.value = '';
            contextInfoEl.style.display = 'none';
            analyzeBtn.disabled = true;
            draftBtn.disabled = true;

            // Chama o backend para análise
            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email_text: emailText })
                });
                const data = await response.json();

                // Tratamento de erro da API
                if (!response.ok || data.error) {
                    let errorMsg = data.error || `Erro HTTP ${response.status}: ${response.statusText}`;
                    if (data.raw_analysis) {
                         errorMsg += ` | Resposta LLM (RAW): ${data.raw_analysis.substring(0, 100)}...`;
                    }
                    throw new Error(errorMsg);
                }

                // Processa a resposta bem-sucedida
                currentAnalysisPoints = data.points || [];
                displayAnalysisResults(data); // Mostra pontos/ações
                createUserInputFields(currentAnalysisPoints); // Cria campos de input
                analysisSection.style.display = 'block'; // Mostra secção de análise

            } catch (error) {
                console.error("Erro durante a análise:", error);
                showError(analyzeErrorEl, `Erro na análise: ${error.message}`);
            } finally {
                // Reativa botões e esconde spinner
                hideSpinner(analyzeSpinner);
                analyzeBtn.disabled = false;
                // Ativa botão de draft apenas se análise ok e houver personas
                if (analysisSection.style.display === 'block' && personaSelect.value && !personaSelect.disabled) {
                    draftBtn.disabled = false;
                }
            }
        });

        // Função: Mostra os resultados da análise (pontos e ações)
        function displayAnalysisResults(data) {
            let html = '<h4>Pontos a Responder:</h4>';
            // Verifica se há pontos reais (não apenas "nenhum ponto")
            const hasRealPoints = data.points && data.points.length > 0 && !(data.points.length === 1 && data.points[0].toLowerCase().includes("nenhum ponto"));

            if (hasRealPoints) {
                html += '<ol class="list-group list-group-numbered list-group-flush">';
                data.points.forEach(point => {
                    html += `<li class="list-group-item">${escapeHtml(point)}</li>`; // Escapa HTML
                });
                html += '</ol>';
            } else {
                 html += '<p class="text-muted">Nenhum ponto específico identificado para resposta direta.</p>';
            }

            // Mostra ações se existirem
            if (data.actions && data.actions.length > 0) {
                html += '<h4 class="mt-3">Ações Sugeridas:</h4>';
                html += '<ul class="list-group list-group-flush">';
                data.actions.forEach(action => {
                    html += `<li class="list-group-item">${escapeHtml(action)}</li>`; // Escapa HTML
                });
                html += '</ul>';
            }
            analysisResultEl.innerHTML = html; // Atualiza o DOM
        }

        // Função: Cria dinamicamente os campos de input para orientação do utilizador
        function createUserInputFields(points) {
            userInputsSection.innerHTML = ''; // Limpa inputs anteriores

            // Função auxiliar para criar um grupo de input (ponto específico ou geral)
            const createGroup = (point, index, isGeneral = false) => {
                const div = document.createElement('div');
                div.className = 'point-input-group';
                const inputId = isGeneral ? 'userInput-general' : `userInput-${index}`;
                // Identificador do ponto ("N/A" para geral ou se ponto for nulo)
                const pointIdentifier = isGeneral ? "N/A" : (point || "N/A");
                // Label diferente para geral vs. específico
                const labelText = isGeneral
                    ? '<strong>Orientação Geral para a Resposta:</strong> (Opcional - se não houver pontos específicos ou quiser dar instruções gerais)'
                    : `<strong>Ponto ${index + 1}:</strong>`;
                // Mostra o texto do ponto original apenas se não for geral
                const pointDisplay = !isGeneral ? `<p class="point-text">"${escapeHtml(point)}"</p>` : '';
                // Textarea é obrigatória apenas para pontos específicos
                const requiredAttr = !isGeneral ? 'required' : '';
                const requiredFeedback = !isGeneral ? '<div class="invalid-feedback">Por favor, forneça resposta/orientação para este ponto.</div>' : '';

                // HTML para os botões de rádio de direção (só para pontos específicos)
                const directionRadiosHTML = !isGeneral ? `
                    <div class="mb-2 guidance-direction-group">
                        <span class="form-label-sm d-block mb-1">Direção Rápida (para Sugestão):</span>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="direction-${index}" id="direction-${index}-sim" value="sim">
                            <label class="form-check-label" for="direction-${index}-sim">Sim</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="direction-${index}" id="direction-${index}-nao" value="nao">
                            <label class="form-check-label" for="direction-${index}-nao">Não</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="direction-${index}" id="direction-${index}-outro" value="outro" checked> <label class="form-check-label" for="direction-${index}-outro">Outro/N/A</label>
                        </div>
                    </div>
                ` : '';

                // HTML para o botão "Sugerir Texto" (só para pontos específicos)
                const suggestButtonHTML = !isGeneral ? `
                    <button class="btn btn-sm btn-outline-secondary suggest-btn"
                            data-target-textarea="${inputId}"
                            data-point-index="${index}"
                            type="button"
                            title="Gerar sugestão de texto com IA para este ponto, usando a Direção Rápida selecionada (se houver)">
                        Sugerir Texto
                        <div class="spinner-border spinner-border-sm text-secondary ms-1 loading-spinner" role="status" style="display: none;"></div>
                    </button>
                ` : '';

                // Monta o HTML do grupo de input
                div.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start mb-1 flex-wrap">
                         <label for="${inputId}" class="form-label mb-0 me-2">${labelText}</label>
                         ${suggestButtonHTML}
                    </div>
                    ${pointDisplay}
                    ${directionRadiosHTML}
                    <textarea class="form-control user-guidance" id="${inputId}" data-point="${escapeHtml(pointIdentifier)}" rows="3" ${requiredAttr} placeholder="Escreva aqui a sua resposta/orientação para este ponto..."></textarea>
                    ${requiredFeedback}
                `;
                userInputsSection.appendChild(div); // Adiciona ao DOM
            };

            // Verifica se há pontos específicos
            const hasRealPoints = points && points.length > 0 && !(points.length === 1 && points[0].toLowerCase().includes("nenhum ponto"));

            if (hasRealPoints) {
                // Cria um grupo para cada ponto específico
                points.forEach((point, index) => {
                    createGroup(point, index, false);
                });
            }
            // Adiciona sempre um campo para orientação geral
            createGroup(null, 'general', true);
        }

        // 2. Event Listener: Botão "Gerar Rascunho"
        draftBtn.addEventListener('click', async () => {
            const originalEmail = originalEmailEl.value.trim();
            const selectedPersona = personaSelect.value;
            const guidanceInputs = userInputsSection.querySelectorAll('.user-guidance');
            let userInputsData = [];
            let formIsValid = true;

            // Limpa erros e esconde secções
            hideError(draftErrorEl);
            contextInfoEl.style.display = 'none';
            refinementControlsEl.style.display = 'none'; // Esconde controlos ao gerar novo rascunho

            // Recolhe e valida as orientações do utilizador
            guidanceInputs.forEach(input => {
                const pointText = input.getAttribute('data-point'); // Ponto original ou "N/A"
                const guidanceText = input.value.trim();

                // Valida apenas campos obrigatórios (pontos específicos)
                if (input.required && !guidanceText) {
                    input.classList.add('is-invalid'); // Marca como inválido
                    if (formIsValid) input.focus(); // Foca o primeiro inválido
                    formIsValid = false; // Marca formulário como inválido
                } else {
                    input.classList.remove('is-invalid'); // Remove estilo de erro se válido
                }
                // Adiciona aos dados se houver orientação OU se for um ponto obrigatório
                if (guidanceText || input.required) {
                     userInputsData.push({ point: pointText, guidance: guidanceText });
                }
            });

            // Para se a validação falhar
            if (!formIsValid) {
                showError(draftErrorEl, "Por favor, forneça resposta/orientação para todos os pontos marcados como obrigatórios.");
                return;
            }
            // Verifica se a persona foi selecionada
            if (!selectedPersona) {
                 showError(draftErrorEl, "Por favor, selecione uma persona.");
                 personaSelect.focus();
                 return;
            }

            // Atualiza UI para processamento
            showSpinner(draftSpinner);
            draftSection.style.display = 'none'; // Esconde secção do rascunho
            generatedDraftEl.value = ''; // Limpa rascunho anterior
            draftBtn.disabled = true; // Desativa botões
            analyzeBtn.disabled = true;

            // Chama o backend para gerar o rascunho
            try {
                 const response = await fetch('/draft', {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         original_email: originalEmail,
                         persona_name: selectedPersona,
                         user_inputs: userInputsData // Envia orientações recolhidas
                     })
                 });
                 const data = await response.json();

                 // Tratamento de erro da API
                 if (!response.ok || data.error) {
                     let errorMsg = data.error || `Erro HTTP ${response.status}: ${response.statusText}`;
                     // Adiciona info de erro da pré-análise se existir
                     if(data.context_analysis && data.context_analysis.error) {
                         errorMsg += ` (Erro na pré-análise: ${data.context_analysis.error})`;
                     }
                     throw new Error(errorMsg);
                 }

                 // Mostra o rascunho gerado
                 generatedDraftEl.value = data.draft;
                 draftSection.style.display = 'block'; // Mostra secção do rascunho

                 // Mostra informação de contexto usada (se disponível)
                 if (data.context_analysis) {
                     contextDetailsEl.textContent = `Categoria: ${data.context_analysis.recipient_category || 'N/A'}, Tom Recebido: ${data.context_analysis.incoming_tone || 'N/A'}, Remetente: ${data.context_analysis.sender_name_guess || 'N/A'}`;
                     contextInfoEl.style.display = 'inline'; // Ou 'block'
                 }

            } catch (error) {
                console.error("Erro durante a geração do rascunho:", error);
                showError(draftErrorEl, `Erro na geração do rascunho: ${error.message}`);
            } finally {
                // Reativa botões e esconde spinner
                hideSpinner(draftSpinner);
                 if (personaSelect.value && !personaSelect.disabled) {
                     draftBtn.disabled = false;
                 }
                analyzeBtn.disabled = false;
            }
        });

        // 3. Event Listener: Botão "Copiar Texto"
        copyDraftBtn.addEventListener('click', () => {
            if (!generatedDraftEl.value) return; // Não faz nada se vazio
            const textToCopy = generatedDraftEl.value;
            // Usa a API Clipboard moderna
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Feedback de sucesso
                const originalText = copyDraftBtn.textContent;
                copyDraftBtn.textContent = 'Copiado!';
                copyDraftBtn.classList.add('btn-success');
                copyDraftBtn.classList.remove('btn-secondary', 'btn-warning');
                // Restaura botão após 2s
                setTimeout(() => {
                    copyDraftBtn.textContent = originalText;
                    copyDraftBtn.classList.remove('btn-success');
                    copyDraftBtn.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                // Fallback para browsers antigos ou se API falhar
                console.warn('Falha ao copiar com navigator.clipboard, tentando fallback:', err);
                try {
                    generatedDraftEl.select(); // Seleciona texto
                    document.execCommand('copy'); // Tenta comando antigo
                    // Feedback de sucesso (fallback)
                    const originalText = copyDraftBtn.textContent;
                    copyDraftBtn.textContent = 'Copiado (Fallback)!';
                    copyDraftBtn.classList.add('btn-warning'); // Cor de aviso
                    copyDraftBtn.classList.remove('btn-secondary', 'btn-success');
                    // Restaura botão após 2s
                    setTimeout(() => {
                        copyDraftBtn.textContent = originalText;
                        copyDraftBtn.classList.remove('btn-warning');
                        copyDraftBtn.classList.add('btn-secondary');
                    }, 2000);
                } catch (execErr) {
                     console.error('Fallback execCommand também falhou:', execErr);
                     alert('Não foi possível copiar o texto automaticamente. Por favor, copie manualmente (Ctrl+C ou Cmd+C).');
                }
            });
        });

        // 4. Event Listener (Delegado): Botões "Sugerir Texto"
        userInputsSection.addEventListener('click', async (event) => {
            // Encontra o botão 'suggest-btn' mais próximo que foi clicado
            const button = event.target.closest('.suggest-btn');
            // Procede apenas se for um botão de sugestão e não estiver desativado
            if (button && !button.disabled) {
                const spinner = button.querySelector('.loading-spinner');
                const targetTextareaId = button.dataset.targetTextarea; // ID da textarea alvo
                const pointIndex = parseInt(button.dataset.pointIndex, 10); // Índice do ponto
                const targetTextarea = document.getElementById(targetTextareaId); // Elemento textarea
                const originalEmail = originalEmailEl.value.trim(); // Email original
                const selectedPersonaName = personaSelect.value; // Persona selecionada

                // Obtém a direção selecionada (Sim/Não/Outro)
                const radioGroupName = `direction-${pointIndex}`;
                const checkedRadio = userInputsSection.querySelector(`input[name="${radioGroupName}"]:checked`);
                const selectedDirection = checkedRadio ? checkedRadio.value : "outro"; // Default 'outro'

                // Obtém o texto do ponto original a partir do array guardado
                const pointToAddress = (currentAnalysisPoints && pointIndex >= 0 && pointIndex < currentAnalysisPoints.length)
                                         ? currentAnalysisPoints[pointIndex]
                                         : null; // Ou tratamento de erro

                // Valida dados necessários
                if (!targetTextarea || !originalEmail || !pointToAddress || !selectedPersonaName || pointToAddress === 'N/A') {
                    console.error("Dados em falta para o pedido de sugestão (email, ponto, persona). Ponto:", pointToAddress);
                    showError(draftErrorEl, "Erro interno: Não foi possível obter dados, ponto ou persona para a sugestão.");
                    return;
                }
                 if (!selectedPersonaName) {
                     showError(draftErrorEl, "Por favor, selecione uma persona antes de pedir sugestões.");
                     personaSelect.focus();
                     return;
                 }

                // Atualiza UI para processamento
                if (spinner) showSpinner(spinner);
                button.disabled = true; // Desativa botão
                hideError(draftErrorEl); // Limpa erros

                // Chama o backend para obter sugestão
                try {
                    const response = await fetch('/suggest_guidance', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            original_email: originalEmail,
                            point_to_address: pointToAddress, // Envia texto do ponto
                            persona_name: selectedPersonaName,
                            direction: selectedDirection // Envia direção
                        })
                    });
                    const data = await response.json();

                    // Tratamento de erro da API
                    if (!response.ok || data.error) {
                         throw new Error(data.error || `Erro HTTP ${response.status}: ${response.statusText}`);
                    }

                    // Preenche a textarea com a sugestão recebida
                    targetTextarea.value = data.suggestion || '';
                    // Dispara evento 'input' para compatibilidade
                    targetTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                    targetTextarea.classList.remove('is-invalid'); // Remove validação de erro se houver

                } catch (error) {
                    console.error("Erro ao obter sugestão de texto:", error);
                    // Mostra erro na área de erro do draft
                    showError(draftErrorEl, `Erro na sugestão: ${error.message}`);
                } finally {
                    // Restaura botão e spinner
                    if (spinner) hideSpinner(spinner);
                    button.disabled = false;
                }
            }
        });

        // --- Lógica para Refinamento de Texto ---

        // 5. Mostrar/Esconder Botões de Refinamento baseado na seleção de texto
        // Eventos para detetar seleção na textarea do rascunho
        generatedDraftEl.addEventListener('select', handleTextSelection);
        generatedDraftEl.addEventListener('mouseup', handleTextSelection); // Garante após clique
        generatedDraftEl.addEventListener('keyup', handleTextSelection); // Garante após escrita/delete

        // Função que mostra/esconde os botões de refinamento
        function handleTextSelection() {
            // Verifica se a secção do rascunho está visível E se há texto selecionado
            if (draftSection.style.display === 'block' &&
                generatedDraftEl.selectionStart !== generatedDraftEl.selectionEnd) {
                refinementControlsEl.style.display = 'flex'; // Mostra botões (usando flex)
            } else {
                refinementControlsEl.style.display = 'none'; // Esconde botões
            }
        }

        // 6. Event Listener (Delegado): Botões de Refinamento
        refinementControlsEl.addEventListener('click', async (event) => {
            // Encontra o botão '.refine-btn' clicado
            const button = event.target.closest('.refine-btn');
            // Procede apenas se for um botão de refinamento e não estiver a refinar
            if (button && !isRefining) {
                const action = button.dataset.action; // Ação a realizar (ex: 'make_formal')
                const spinner = button.querySelector('.loading-spinner'); // Spinner do botão

                // Obtém o texto selecionado, o contexto completo e a persona
                const selectedText = generatedDraftEl.value.substring(generatedDraftEl.selectionStart, generatedDraftEl.selectionEnd);
                const fullContext = generatedDraftEl.value; // Texto completo atual
                const selectedPersonaName = personaSelect.value;
                const start = generatedDraftEl.selectionStart; // Posição inicial da seleção
                const end = generatedDraftEl.selectionEnd; // Posição final da seleção

                // Validações
                if (!selectedText) {
                    // showError(draftErrorEl, "Nenhum texto selecionado para refinar."); // Mensagem opcional
                    refinementControlsEl.style.display = 'none'; // Esconde se seleção desapareceu
                    return;
                }
                 if (!selectedPersonaName) {
                    showError(draftErrorEl, "Por favor, selecione uma persona para o refinamento.");
                     personaSelect.focus();
                    return;
                }

                // Ativa flag, mostra spinner, desativa TODOS os botões de refinamento
                isRefining = true;
                if(spinner) showSpinner(spinner);
                refinementControlsEl.querySelectorAll('.refine-btn').forEach(btn => btn.disabled = true);
                hideError(draftErrorEl); // Limpa erros anteriores

                // Chama o backend para refinar o texto
                try {
                    const response = await fetch('/refine_text', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            selected_text: selectedText,
                            full_context: fullContext,
                            action: action,
                            persona_name: selectedPersonaName
                        })
                    });
                    const data = await response.json();

                    // Tratamento de erro da API
                    if (!response.ok || data.error) {
                        throw new Error(data.error || `Erro HTTP ${response.status}: ${response.statusText}`);
                    }

                    // === Substitui o texto selecionado pelo texto refinado ===
                    const before = fullContext.substring(0, start); // Texto antes da seleção
                    const after = fullContext.substring(end); // Texto depois da seleção
                    const refinedText = data.refined_text || ""; // Texto refinado (ou vazio)

                    generatedDraftEl.value = before + refinedText + after; // Concatena

                    // Ajusta a posição do cursor para o fim do texto inserido
                    generatedDraftEl.focus();
                    const newCursorPos = start + refinedText.length;
                    generatedDraftEl.setSelectionRange(newCursorPos, newCursorPos);

                } catch (error) {
                     console.error(`Erro ao refinar texto (Ação: ${action}):`, error);
                     showError(draftErrorEl, `Erro no refinamento (${action}): ${error.message}`);
                 } finally {
                     // Restaura UI: esconde spinner, reativa botões, desativa flag
                     if(spinner) hideSpinner(spinner);
                     refinementControlsEl.querySelectorAll('.refine-btn').forEach(btn => btn.disabled = false);
                     isRefining = false;
                     handleTextSelection(); // Reavalia visibilidade dos botões
                 }
            }
        });

    </script>
</body>
</html>
